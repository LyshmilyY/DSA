# 串

## 1. 串的定义和实现

### 1.1 串的定义 
串（**String**）是由零个或者多个字符组成的有限序列

$$
S = ''a_{1}a_{2}\cdots a_{n}'' (n\geq 0)
$$

- $S$ 是串名, 双引号内的字符序列是串的值；$a_{i}(1\leq i \leq n)$ 可以是字母、数字或其他字符
- 串中字符的数目 $n$ 称为串的<font color="#ff0000">长度</font>, 零个字符的串称为<font color="#ff0000">空串</font>, 长度为零
- 串中任意个连续字符组成的子序列称为该串的<font color="#ff0000">子串</font>, 包含子串的串称为<font color="#ff0000">主串</font>
- 字符在系列中的序号为该字符在串中的<font color="#ff0000">位置</font>, 子串在主串中的位置以子串的第一个字符在主串中的位置表示
- 两个串相等当且仅当两个串长度相等且各个位置的字符都对应相等, 由一个或多个空格组成的串称为<font color="#ff0000">空格串</font>, 空串用符号 $\emptyset$ 表示


### 1.2 串的存储结构

#### 1.2.1 定长顺序存储

``` c
#define MAXSIZE 255
typedef struct SString{
    char ch[MAXSIZE];
    int Length;
}SString;
```

#### 1.2.2 堆分配存储

``` c
typedef struct HString{
    char *ch;
    int Length;
}HString;
```

#### 1.2.3 块链存储

``` c
#define CHUNKSZIE 4
typedef struct Chunk{
    char ch[CHUNKSZIE];
    struct Chunk *next;
}Chunk;
typedef struct LString{
    Chunk *head;
    Chunk *tail;
    int Length;
}LString;
```

### 1.3 串的基本操作

``` c
// 串的基本操作
void StrAssign(String* T, char* chars) // 初始化 
void StrCopy(String* T, String S) // 复制
bool StrEmpty(String S) // 判空
bool StrCompare(String S, String T) // 比较
int StrLength(String S) // 长度
void ClearString(String S) // 清空
bool Concat(String* T, String S1, String S2) // 链接
bool SubString(String* Sub, String S, int pos, int length) // 求子串
int Index(String S, String T) // 子串位置
bool StrInsert(String* S, int pos, String T) // 插入
bool StrDelete(String* S, int pos, int length) // 删除
```

## 2. 串的模式匹配

- 子串的定位通常称为<font color="#0070c0">模式匹配</font>或串匹配, 在搜索引擎、拼写检查、语言翻译、数据压缩等领域有广泛的应用
- 串的模式匹配设有两个字符串 $S$ 和 $T$, 其中 $S$ 为主串，$T$ 为模式串, 在主串 $S$ 中查找与模式串 $T$ 相匹配的串, 确定相匹配的子串中第一个字符在主串 $S$ 的位置

### 2.1 朴素匹配算法

- 朴素匹配算法, 主串每次匹配失败都要回溯到 $i = i - j + 1$, 子串要回溯到 $j = 0$ 位置, 时间复杂度 $O(n\times m)$

```c
int Index(String S, String,T)
{
    int i = 0, j = 0;
    while (i <= S.Length -1 && j <= T.Length - 1)
    {
        if (S.ch[i] == T.ch[j])
        {
            i++;
            j++;
        }
        else
        {
            i = i - j + 1;
            j = 0;
		}
	}
    if (j == T.Length)
        return i - T.Length + 1;
    else
        return 0;
}
```

|  **主串**  | **a** | **b** | **a** | **a** | **b** | **a** | **a** | **b** | **c** | **a** | **b** | **a** | **a** | **b** | **c** |
| :--------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **模式串** | **a** | **b** | **a** | **a** | **b** | **c** |       |       |       |       |       |       |       |       |       |

朴素字符串匹配算法来匹配上面的主串和模式串:

1. $i$ 是主串 $S$ 的指针, $j$ 是模式串$T$的指针
2. 首先让 $i = j = 0$, 依次比较 $S[i]$ 与 $T[j]$ 是否相等
3. 遇到 $S[i]\neq T[j]$, 让主串指针 $i = i - j + 1$, 让模式串指针 $j=0$
4. 循环终止条件为: `i > S.Length|| j > T.Length` 
5. 循环终止后, 我们判断 `j == T.length`, 如果是证明匹配成功, 不是则代表失败

第一次匹配:

|  **主串**  | **a** | **b** | **a** | **a** | **b** |               **a**                | **a** | **b** | **c** | **a** | **b** | **a** | **a** | **b** | **c** |
| :--------: | :---: | :---: | :---: | :---: | :---: | :--------------------------------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **模式串** | **a** | **b** | **a** | **a** | **b** | **<font color="#ff0000">c</font>** |       |       |       |       |       |       |       |       |       |

$i = j = 5$, 出现失配情况, 令 $i = i - j + 1 = 1, j = 0$, 重新开始配对

第二次匹配:

|  **主串**  | **a** |               **b**                | **a** | **a** | **b** | **a** | **a** | **b** | **c** | **a** | **b** | **a** | **a** | **b** | **c** |
| :--------: | :---: | :--------------------------------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **模式串** |       | **<font color="#ff0000">a</font>** | **b** | **a** | **a** | **b** | **c** |       |       |       |       |       |       |       |       |

$i = 1, j = 0$, 出现失配情况, 令 $i = i - j + 1 = 2, j = 0$, 

$\cdots\cdots\cdots\cdots$

|  **主串**  | **a** | **b** | **a** | **a** | **b** | **a** | **a** | **b** | **c** | **a** | **b** | **a** | **a** | **b** | **c** |
| :--------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **模式串** |       |       |       | **a** | **b** | **a** | **a** | **b** | **c** |       |       |       |       |       |       | 


$i = 9, j = 6$, 循环结束,与模式串匹配的子串的起始位置为 $i - T.Length + 1 = 4$


### 2.2  KMP 字符串匹配算法

- 充分利用模式串, 使得主串指针在遍历时只遍历一遍不出现回溯的情况
- 我们要保证 $i$ 遍历一遍, 要充分利用模式串, 当模式串的第 $j$ 位失配时, 如何将模式串向右滑动

#### 2.2.1 模式串最大前缀后缀匹配算法
- 1. $i$ 代表模式串的第 $i + 1(0\sim T.Length - 1)$ 位
- 2. $j$ 代表前 $i - 1$ 位模式串的最大前缀后缀中前缀的最后一个字符的下标 
- 3. `next[i]` 表示前 $i + 1$ 位模式串的最大前缀后缀中前缀的最后一个字符的下标 
- 4. 特殊的, 初始时, `next[0] = -1`, 表示单个字符无前缀后缀, $i = 1$, 为方便比较, 令 $j = 0$
- 5. 比较 `T.ch[i] == T.ch[j]`, 如果相等, 说明 `next[i] = next[j] + 1`, 令 `i++; j++`, 循环继续
- 6. 如果 `T.ch[i] != T.ch[j]`, 
- 在模式串第 $j$ 位失配时, $j$ 对应的值形成一个数组 $next$
- 我们要求出 $next$ 数组,再对主串进行遍历

```c
int KMP(String S, String T, int next[])
{
    int i = 0, j = 0;
    while (i <= S.Length -1 && j <= T.Length -1)
    {
        if (j == -1 || S.ch[i] == T.ch[j])
        {
            i++;
            j++;
        }
        else
        {
            j = next[j];
        }
    }
    if (j > T.Length)
        return i - T.Length + 1;
    else
        return 0;
}

```

|     a | b     | a     | a     | b     | ？                           | ？   | ？   | ？   | ？   | ？   | ？   | ？   | ？   | ？   |
| ----: | ----- | ----- | ----- | ----- | ---------------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **a** | **b** | **a** | **a** | **b** | **<font color=red>c</font>** |      |      |      |      |      |      |      |      |      |

此时:$j=6$发生失配情况,我们针对此模式串,令$j=3$,重新比较$S[i]$与$T[j]$

| **?** | ?    | **?** | a     | b     | **a** | **a** | ？                           | ？    | ？   | ？   | ？   | ？   | ？   | ？   |
| ----: | ---- | ----- | ----- | ----- | ----- | ----- | ---------------------------- | ----- | ---- | ---- | ---- | ---- | ---- | ---- |
|       |      |       | **a** | **b** | **a** | **a** | **<font color=red>b</font>** | **c** |      |      |      |      |      |      |

此时:$j=5$发生失配情况,我们针对此模式串,令$j=2$,重新比较$S[i]$与$T[j]$

| **?** | ?    | **?** | a     | b     | **a** | **?**                        | ？    | ？    | ？   | ？   | ？   | ？   | ？   | ？   |
| ----: | ---- | ----- | ----- | ----- | ----- | ---------------------------- | ----- | ----- | ---- | ---- | ---- | ---- | ---- | ---- |
|       |      |       | **a** | **b** | **a** | **<font color=red>b</font>** | **b** | **c** |      |      |      |      |      |      |

此时:$j=4$发生失配情况,我们针对此模式串,令$j=2$,重新比较$S[i]$与$T[j]$

- 在一些特殊的模式串情况下,可以优化,比如在此情况下,$j=1$

| **?** | ?    | **?** | a     | b     | **?**                        | **?** | ？    | ？    | ？   | ？   | ？   | ？   | ？   | ？   |
| ----: | ---- | ----- | ----- | ----- | ---------------------------- | ----- | ----- | ----- | ---- | ---- | ---- | ---- | ---- | ---- |
|       |      |       | **a** | **b** | **<font color=red>a</font>** | **b** | **b** | **c** |      |      |      |      |      |      |

此时:$j=3$发生失配情况,我们针对此模式串,令$j=1$,重新比较$S[i]$与$T[j]$

- 在一些特殊的模式串情况下,可以优化,比如在此情况下,$j=0$,$i+=1,j+=1$

| **?** | ?    | **?** | a     | **?**                        | **?** | **?** | ？    | ？    | ？   | ？   | ？   | ？   | ？   | ？   |
| ----: | ---- | ----- | ----- | ---------------------------- | ----- | ----- | ----- | ----- | ---- | ---- | ---- | ---- | ---- | ---- |
|       |      |       | **a** | **<font color=red>b</font>** | **a** | **b** | **b** | **c** |      |      |      |      |      |      |

此时:$j=2$发生失配情况,我们针对此模式串,令$j=1$,重新比较$S[i]$与$T[j]$

| **?** | ?    | **?** | **?**                        | **?** | **?** | **?** | ？    | ？    | ？   | ？   | ？   | ？   | ？   | ？   |
| ----: | ---- | ----- | ---------------------------- | ----- | ----- | ----- | ----- | ----- | ---- | ---- | ---- | ---- | ---- | ---- |
|       |      |       | **<font color=red>a</font>** | **b** | **a** | **b** | **b** | **c** |      |      |      |      |      |      |

此时:$j=1$发生失配情况,我们针对此模式串,令$j=0$,$i+=1,j+=1$,重新比较$S[i]$与$T[j]$

### $Next$ 数组求解

$$
next[j]=\left\{ \begin{align*}
&0,\quad j=1&\\
&max\{k|1<k<j\},\quad 且p_{1}\cdots p_{k-1}=p_{j-k+1}\cdots p_{j-1}p_{j}&\\
&1,\quad 不存在前缀和后缀相等&
\end{align*}
\right.
$$

