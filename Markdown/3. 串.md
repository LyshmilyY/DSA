# 串

## 一、基本概念

==串的概念==:串（**String**）是由零个或者多个==字符==组成的==有限序列==
$$
S='a_{1}a_{2}\cdots a_{n}'\quad (n\geq 0)
$$

- **$S$** 是串名；单引号内的字符序列是串的值；$n$ 称为串的长度,当 $n=0$ 时为空串
- 串中任意多个==连续字符组成的子序列==称为该串的==子串==
- 子串在主串中的位置以子串的第一个元素在主串中出现的位置表示

## 二、存储结构和实现

### 1. 串的基本操作

```c
//初始化、判空、比较、赋值、求字符串长度、求子串、清除和销毁
StrAssign(&T,chars)//赋值操作,将chars的值赋值给T
StrCopy(&T,S)//将字符串S复制给T
StrEmpty(S)//判断字符串S是否为空
StrCompare(S,T)//按照位依次比较两个串是否相等,S==T返回值=0；S>T返回值>0；S<T返回值<0
StrLength(S)//串的长度
Concat(&T,S1,S2)//链接两个串,赋值给T
Index(S,T)//返回子串S第一次出现在主串S的位置,没有返回0
SubString(&Sub,S,pos,length)//求主串S在pos位置长度为length的子串,赋值给Sub
```

### 2. 串的顺序存储实现

```c
#include<stdio.h>
#include<stdlib.h>
#include<stdbool.h>
#include<string.h>
#define MAXSIZE 100
typedef struct SString{
    char ch[MAXSIZE];
    int lenght;
}SString;

//函数声明
void StrAssign(SString *T,char *chars);
void StrCopy(SString *T,SString S);
bool StrEmpty(SString S);
int StrCompare(SString S,SString T);
int StrLength(SString S);
void ClearString(SString *S);
void Concat(SString *T,SString S1,SString S2);
void SubString(SString *Sub,SString S,int pos,int len);
int Index(SString S,SString T);

//赋值
void StrAssign(SString *T,char *chars){
    int i;
    for(i=0;chars[i]!='\0';i++){
        T->ch[i]=chars[i];
    }
    T->lenght=i;
}

//复制
void StrCopy(SString *T,SString S){
    int i;
    for(i=0;i<S.lenght;i++){
        T->ch[i]=S.ch[i];
    }
    T->lenght=S.lenght;
}

//判空
bool StrEmpty(SString S){
    return (S.lenght==0);
}

//比较
int StrCompare(SString S,SString T){
    int i;
    for(i=0;i<S.lenght&&i<T.lenght;i++){
        if(S.ch[i]!=T.ch[i]){
            return S.ch[i]-T.ch[i];
        }
    }
    return S.lenght-T.lenght;
}

//求串长
int StrLength(SString S){
    return S.lenght;
}

//清空
void ClearString(SString *S){
    S->lenght=0;
}

//连接
void Concat(SString *T,SString S1,SString S2){
    int i;
    for(i=0;i<S1.lenght;i++){
        T->ch[i]=S1.ch[i];
    }
    for(i=0;i<S2.lenght;i++){
        T->ch[S1.lenght+i]=S2.ch[i];
    }
    T->lenght=S1.lenght+S2.lenght;
}

//求子串
void SubString(SString *Sub,SString S,int pos,int len){
    int i;
    for(i=0;i<len;i++){
        Sub->ch[i]=S.ch[pos+i-1];
    }
    Sub->lenght=len;
}

//定位
int Index(SString S,SString T){
    int i=1,n=StrLength(S),m=StrLength(T);
    SString sub;
    while(i<=n-m+1){
        SubString(&sub,S,i,m);
        if(StrCompare(sub,T)!=0){
            ++i;
        }else{
            return i;
        }
    }
    return 0;
}

```

### 3. 串的链式存储实现

- ==每个节点可能存放多个字符==

## 三、模式匹配算法

### 1. 朴素匹配算法

```c
int Index(SString S,SString,T)
{
    int i=1,j=1;
    while (i<=S.length && j<=T.length)
    {
        if (S.ch[i]==T.ch[j])
        {
            ++i;++j;
        }
        else
        {
            i=i-j+2;
            j=1;
		}
	}
    if (j>T.length)
        return i-T.length;
    else
        return 0;
}
```

| a     | b     | a     | a     | b     | a     | a    | b    | c    | a    | b    | a    | a    | b    | c    |
| ----- | ----- | ----- | ----- | ----- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **a** | **b** | **a** | **a** | **b** | **c** |      |      |      |      |      |      |      |      |      |

我们利用朴素字符串匹配算法来匹配上面的主串和模式串:

- $i$是主串$S$的指针,$j$是模式串$T$的指针
- 首先让$i=j=1$,依次比较$S[i]$与$T[j]$是否相等
- 遇到$S[i]\neq T[j]$我们让主串指针$i=i-j+2$,让模式串指针$j=1$
- 循环终止条件为:$i>S.length$||$j>T.length$
- 循环终止后,我们判断$j>T.length$,如果是证明匹配成功,不是则代表失败

|     a | b     | a     | a     | b     | a                            | a    | b    | c    | a    | b    | a    | a    | b    | c    |
| ----: | ----- | ----- | ----- | ----- | ---------------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **a** | **b** | **a** | **a** | **b** | **<font color=red>c</font>** |      |      |      |      |      |      |      |      |      |

此时:$i=j=6$,出现失配情况,我们令$i=i-j+2=2$,$j=1$,重新开始配对

| a    | b                            | a     | a     | b     | a     | a     | b    | c    | a    | b    | a    | a    | b    | c    |
| ---- | ---------------------------- | ----- | ----- | ----- | ----- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      | **<font color=red>a</font>** | **b** | **a** | **a** | **b** | **c** |      |      |      |      |      |      |      |      |

此时:$i=2,j=1$,出现失配情况,我们令$i=i-j+2=3$,$j=1$,重新开始配对
$\cdots$

| a    | b    | a    | a     | b     | a     | a     | b     | c     | a    | b    | a    | a    | b    | c    |
| ---- | ---- | ---- | ----- | ----- | ----- | ----- | ----- | ----- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      | **a** | **b** | **a** | **a** | **b** | **c** |      |      |      |      |      |      |

此时:$i=10,j=7$,循环结束,与模式串匹配的子串的起始位置为$i-T.length=4$


### 2.  KMP 字符串匹配算法

- ==充分利用模式串,使得主串在指针在遍历时只遍历一遍不出现回溯的情况==
- 我们要保证$i$遍历一遍,要充分利用模式串,当模式串的第$j$位失配时我们的应对情况
- 在模式串第$j$位失配时,$j$对应的值形成一个数组$next$
- 我们要求出$next$数组,再对主串进行遍历

```c
int KMP(SString S,SString T,int next[])
{
    int i=1,j=1;
    while (i<=S.length && j<=T.length)
    {
        if (j==0||S.ch[i]==T.ch[j])
        {
            i++;j++;
        }
        else
        {
            j=next[j];
        }
    }
    if (j>T.length)
        return i-T.length;
    else
        return 0;
}
```

|     a | b     | a     | a     | b     | ？                           | ？   | ？   | ？   | ？   | ？   | ？   | ？   | ？   | ？   |
| ----: | ----- | ----- | ----- | ----- | ---------------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **a** | **b** | **a** | **a** | **b** | **<font color=red>c</font>** |      |      |      |      |      |      |      |      |      |

此时:$j=6$发生失配情况,我们针对此模式串,令$j=3$,重新比较$S[i]$与$T[j]$

| **?** | ?    | **?** | a     | b     | **a** | **a** | ？                           | ？    | ？   | ？   | ？   | ？   | ？   | ？   |
| ----: | ---- | ----- | ----- | ----- | ----- | ----- | ---------------------------- | ----- | ---- | ---- | ---- | ---- | ---- | ---- |
|       |      |       | **a** | **b** | **a** | **a** | **<font color=red>b</font>** | **c** |      |      |      |      |      |      |

此时:$j=5$发生失配情况,我们针对此模式串,令$j=2$,重新比较$S[i]$与$T[j]$

| **?** | ?    | **?** | a     | b     | **a** | **?**                        | ？    | ？    | ？   | ？   | ？   | ？   | ？   | ？   |
| ----: | ---- | ----- | ----- | ----- | ----- | ---------------------------- | ----- | ----- | ---- | ---- | ---- | ---- | ---- | ---- |
|       |      |       | **a** | **b** | **a** | **<font color=red>b</font>** | **b** | **c** |      |      |      |      |      |      |

此时:$j=4$发生失配情况,我们针对此模式串,令$j=2$,重新比较$S[i]$与$T[j]$

- 在一些特殊的模式串情况下,可以优化,比如在此情况下,$j=1$

| **?** | ?    | **?** | a     | b     | **?**                        | **?** | ？    | ？    | ？   | ？   | ？   | ？   | ？   | ？   |
| ----: | ---- | ----- | ----- | ----- | ---------------------------- | ----- | ----- | ----- | ---- | ---- | ---- | ---- | ---- | ---- |
|       |      |       | **a** | **b** | **<font color=red>a</font>** | **b** | **b** | **c** |      |      |      |      |      |      |

此时:$j=3$发生失配情况,我们针对此模式串,令$j=1$,重新比较$S[i]$与$T[j]$

- 在一些特殊的模式串情况下,可以优化,比如在此情况下,$j=0$,$i+=1,j+=1$

| **?** | ?    | **?** | a     | **?**                        | **?** | **?** | ？    | ？    | ？   | ？   | ？   | ？   | ？   | ？   |
| ----: | ---- | ----- | ----- | ---------------------------- | ----- | ----- | ----- | ----- | ---- | ---- | ---- | ---- | ---- | ---- |
|       |      |       | **a** | **<font color=red>b</font>** | **a** | **b** | **b** | **c** |      |      |      |      |      |      |

此时:$j=2$发生失配情况,我们针对此模式串,令$j=1$,重新比较$S[i]$与$T[j]$

| **?** | ?    | **?** | **?**                        | **?** | **?** | **?** | ？    | ？    | ？   | ？   | ？   | ？   | ？   | ？   |
| ----: | ---- | ----- | ---------------------------- | ----- | ----- | ----- | ----- | ----- | ---- | ---- | ---- | ---- | ---- | ---- |
|       |      |       | **<font color=red>a</font>** | **b** | **a** | **b** | **b** | **c** |      |      |      |      |      |      |

此时:$j=1$发生失配情况,我们针对此模式串,令$j=0$,$i+=1,j+=1$,重新比较$S[i]$与$T[j]$

### $Next$ 数组求解

$$
next[j]=\left\{ \begin{align*}
&0,\quad j=1&\\
&max\{k|1<k<j\},\quad 且p_{1}\cdots p_{k-1}=p_{j-k+1}\cdots p_{j-1}p_{j}&\\
&1,\quad 不存在前缀和后缀相等&
\end{align*}
\right.
$$

