# 图

## 一、基本概念

图$G$由==顶点集$V$和边集$E$==组成,记为$G=\{V,E\}$,其中$V(G)$表示图$G$中顶点的有限非空集合,$E(G)$表示图$G$中顶点之间关系集合。我们用$|V|$表示图$G$顶点的个数,也称为==图形的阶==,$|E|$表示图$G$中边的条数。

- ==有向图==:微博、$B$站粉丝

- ==无向图==:微信好友

- ==度==:对于无向图,度指的是依附于该顶点的边的条数,记为$TD(v)$；对于有向图,度包含入度$ID(v)$和出度$OD(v)$,顶点的度为$TD(v)=ID(v)+OD(v)$

- ==路径==:顶点$v_{p}$到顶点$v_{q}$之间的一条路径指的是顶点序列$v_{p},v_{i_{1}},v_{i_{{2}}},\cdots,v_{q}$

- ==回路==:第一个顶点和最后一个顶点相同的路径称为==回路或者环==

- ==连通和强连通==:在无向图中顶点$v$和顶点$u$之间有路径存在,我们称$u,v$是==连通==的；在无向图中,顶点$v$和顶点$u$之间有双向路径存在,我们称$u,v$是强连通的.

- ==连通图和强连通图==:前者指的是在无向图中,任意两个顶点都是连通的；后者指的是在有向图中任意两个顶点都是强连通的。

- 对于$n$个节点的无向图,如果是连通图,至少有$n-1$条边；如果是非连通图,至多有$C_{n-1}^{2}$条边

- 对于$n$个节点的有向图,如果是强连通图,至少有$n$条边

- ==连通分量==:==无向图==中的==极大==连通子图

- ==强连通分量==:==有向图==的极大强连通子图

- ==生成树==:连通图的生成树是包含全部顶点的一个==极小连通子图==

- ==生成森林==:非连通图中,连通分量的生成树构成了非连通图的==生成森林==

- ==带权图、带权路径==:前者指的是图中边带有权值；后者指的是==一条路径上所有权值之和==

- ==完全图==:任意两个顶点之间都存在边；对于无向图,$|E|\in [0,C_{n}^{2}]$；对于有向图,$|E|\in[0,2C_{n}^{2}]$

- ==稀疏图==:边数量很少的图,标准没有绝对的界限,一般$|E|<|V|log|V|$

  ![](https://cdn.jsdelivr.net/gh/LyshmilyY/MuYiPicture@main/DSA/%E5%9B%BE%E6%A6%82%E5%BF%B5.png)

## 二、图的存储

## 1. 邻接矩阵法

- 只与==顶点数$|V|$==有关,与边的数量无关

  ```c
  #define MAXVertexNum 100
  #define INFINTY
  typedef struct {
      char Vex[MAXVertexNum];
      int Edge[MAXVertexNum][MAXVertexNum];
      int vexnum,edgenum;//顶点数和边的数量
  }
  ```

- 空间复杂度$O(|V|^{2})$,适用于稠密图；计算入度和出度时间复杂度为$O(|V|)$

  ![](https://cdn.jsdelivr.net/gh/LyshmilyY/MuYiPicture@main/DSA/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png)

## 2. 邻接表（类似于==树的孩子表示法==）

```c
typedef struct ArcNode{
    int adjvex;
    struct ArcNode *next
}ArcNode;
typedef struct VNode{
    int data;
    ArcNode* first;
}VNode,AdjList[MAXVertexNum];
```

![](https://cdn.jsdelivr.net/gh/LyshmilyY/MuYiPicture@main/DSA/%E9%82%BB%E6%8E%A5%E8%A1%A8.png)



## 3. 十字链表（==有向图==）

![](https://cdn.jsdelivr.net/gh/LyshmilyY/MuYiPicture@main/DSA/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8.png)

## 4. 邻接多重表（==无向图==）

![](https://cdn.jsdelivr.net/gh/LyshmilyY/MuYiPicture@main/DSA/%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8.png)

|                    | 邻接表                                  | 邻接矩阵           | 十字链表     | 邻接多重表   |
| ------------------ | --------------------------------------- | ------------------ | ------------ | ------------ |
| 空间复杂度         | 无向图$O(|V|+2|E|)$,有向图$O(|V|+|E|)$ | $O(|V|^2)$         | $O(|V|+|E|)$ | $O(|V|+|E|)$ |
| 适用情况           | 存储稀疏图                              | 存储稠密图         | 有向图       | 无向图       |
| 表示方式           | 不唯一                                  | 唯一               | 不唯一       | 不唯一       |
| 计算度(入度、出度) | 计算有向图的度、入度不方便              | 遍历对应的行或者列 | 方便         | 方便         |
| 找相邻的边         | 找有向图的入边不方便                    | 遍历对应的行或者列 | 方便         | 方便         |

## 三、图的基本操作

```c
Adjacent(G,x,y);//判断图G是否存在边(x,y)
Neighbors(G,x);//列出与顶点x相邻的边
InSertVertex(G,x);//在图G中插入顶点x
DeleteVertex(G,x);//从图G中删除顶点x
AddEdge(G,x,y);//如果图G中不存在(x,y)或者<x,y>,添加边
RemoveEdge(G,x,y);//如果图G中存在(x,y)或者<x,y>,删除边
FirstNeighbor(G,x);//求图G中顶点x的第一个邻接点,不存在返回-1
NextNeighbor(G,x,y);//求图G中顶点x除了y的第一个邻接点,不存在返回-1
Get_edge_value(G,x,y);
Set_edge_value(G,x,y);
```

## 四、图的遍历（$DFS\Rightarrow\text{栈}$,$BFS\Rightarrow\text{队列}$）

**树的遍历不需要考虑已经访问过的节点,图需要考虑节点是否被访问过**

### 1. BFS  广度优先搜索

- 图非空,第一个节点入队

- 如果队列非空,队头元素出队并访问,同时将该元素的邻接点加入队列,重复操作至队列为空

  ```c
  #define MAXSIZE 100 
  bool visited[MAXSIZE];
  void BFSTraverse(Graph G)
  {
      for (int i=0;i<G.vexnum;i++)
          visited[i]=false;
      InitQueue(Q);
      for(int i=0;i<G.vexnum;i++){
          if (!visited[i])
              BFS(G,i);
      }
  }
  
  void BFS(Graph G,int v)
  {
      visit(v);
      visited[v]=true;
      EnQueue(Q,v);
      while(!IsEmpty(Q))
      {
          DeQueue(Q,v);
          for (w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w))
          {
              if (!visited[w]){
                  visit(w);
                  visited[w]=true;
                  EnQueue(Q,w);
              }
          }
      }
  }
  ```


### 2. DFS  深度优先搜索

```c
//递归实现
#define MAXSIZE 100 
bool visited[MAXSIZE];
void BFSTraverse(Graph G)
{
    for (int i=0;i<G.vexnum;i++)
        visited[i]=false;
    for(int i=0;i<G.vexnum;i++){
        if (!visited[i])
            DFS(G,i);
    }
}

void DFS(Graph G,int v)
{
    visit(v);
    visited[v]=true;
    for (w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w))
    {
        if (!visited[w]){
            visit(w);
            DFS(G,w);
        }
    }
}
//非递归实现
```

==对于非连通图,无法遍历所有节点；调用$BFS\text{和}DFS$函数次数$=$连通分量数==

1. **空间复杂度:最坏情况下,辅助队列大小为$O(|V|)$**

2. **广度优先生成树:广度优先遍历确定的树；深度优先生成树:深度优先遍历确定的树**
3. ==邻接表==存储的图生成树==不唯一==,==邻接矩阵==存储的图生成树==唯一==
4. **遍历非连通图可以得到广度优先森林和深度优先森林**

  |                | 邻接矩阵     | 邻接表       |
| -------------- | ------------ | ------------ |
  | **时间复杂度** | $O(|V|^{2})$ | $O(|V|+|E|)$ |
| **空间复杂度** | $O(|V|)$     | $O(|V|)$     |

## 五、最小生成树和最短路径

### 1. 最小生成树

==连通图的生成树是包含图中全部顶点的一个极小连通子图==

**对于一个带权连通无向图$G=(V,E)$,生成树不同,设$R$是$G$所有生成树的集合,若$T$是集合$R$中所有边权值之和最小的生成树,称$T$为$G$的最小生成树**

==求最小生成树算法==

- $Prim$算法       **时间复杂度:$O(|V|^2)$,适用于边稠密图**

  ==从某一个顶点开始构建生成树；每次将代价最小的顶点纳入生成树直到所有的顶点都在生成树内==

- $Kruskal$算法      **时间复杂度:$O(|E|log_{2}|E|)$,适用于边稀疏图**

  每次选择一条权值最小的边,使这条边的两头连通（已经连通的不选）,直到所有节点连通

### 2. 最短路径问题

####   单源最短路径 ==$BFS$算法==（无权图）

```c
//path[]记录路径; d[]记录长度
#define MAXSIZE 100 
bool visited[MAXSIZE];
int d[MAXSIZE];
int path[MAXSIZE];
void BFS_MIN_Distance(Graph G,int u)
{
    for (int i=0;i<G.vexnum;i++)
    {
        d[i]=+infty;
        path[i]=-1
    }
    d[u]=0;
    visited[v]=true;
    EnQueue(Q,v);
    while(!IsEmpty(Q))
    {
        DeQueue(Q,v);
        for (w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w))
        {
            if (!visited[w]){
                d[w]=d[u]+1;
                path[w]=u;
                visited[w]=true;
                EnQueue(Q,w);
            }
        }
    }
}
```

####   单源最短路径 ==$Dijkstra$算法==（带权图和无权图）==权值为正==

- 将开始节点的所有边加入最小堆,选择堆顶元素,然后将堆顶元素的边加入,重新计算与开始节点的距离,将最小堆重新排序
- 重复上述步骤直至所有节点都选择完毕

![](https://cdn.jsdelivr.net/gh/LyshmilyY/MuYiPicture@main/DSA/Dijkstra.png)

| 顶点            | $v_{0}$ | $v_{4}$ | $v_{1}$ |
| --------------- | ------- | ------- | ------- |
| 距离$V_{0}$距离 | 0       | 5       | 10      |

我们将$v_{0}$出堆,选择最小的距离$v_{0}v_{4}$,将$v_{4}$的边$\{v_{1}、v_{3}、v_{2}\}$加入堆,已经访问的节点$\{v_{0}、v_{4}\}$

| 顶点            | $v_{3}$ | $v_{1}$ | $v_{2}$ |
| --------------- | ------- | ------- | ------- |
| 距离$V_{0}$距离 | 7       | 8       | 14      |

我们将$v_{3}$出堆,加入$v_{3}$的边$\{v_{2}、v_{0}\}$,已经访问的节点$\{v_{0}、v_{4}、v_{3}\}$

| 顶点            | $v_{1}$ | $v_{2}$ |
| --------------- | ------- | ------- |
| 距离$V_{0}$距离 | 8       | 13      |

我们将$v_{1}$出堆,加入$v_{1}$的边$\{v_{2}、v_{4}\}$,已经访问的节点$\{v_{0}、v_{4}、v_{3}、v_{1}\}$

| 顶点            | $v_{2}$ |
| --------------- | ------- |
| 距离$V_{0}$距离 | 9       |

将$v_{2}$出堆,所有元素都已访问

#### 各顶点之间最短路径==$Floyd$算法==  不能解决负权回路

```c
//Floyd算法,动态规划思想
for (int k=0;k<n;k++)//以vk作为中转点
{
    for (int i=0;i<n;i++)
    {
        for (int j=0;j<n;j++)
        {
            if (A[i][j]>A[i][k]+A[k][j])
            {
                A[i][j]=A[i][k]+A[k][j];
                path[i][j]=k;
            }
        }
    }
}
```

## 六、有向无环图 $DAG$

- **有向无环图:若一个有向图中不存在环,则称为有向无环图,简称为$DAG$**

$DAG$**描述表达式**

- 将操作数不重复的列出然后标注计算顺序
- 合并多余的操作符

## 七、拓朴排序

$AOV$网一定是$DAG$

- 寻找入度为$0$的节点,将这个节点入栈
- 将栈中元素出栈,删除与这个节点形成的边
- 重复前两步直到图中没有入度为$0$的节点

```c
//邻接表实现图
typedef struct ArcNode{
    int adjvex;
    atruct ArcNode* nextarc;
}ArcNode;
typedef struct VNode{
    int data;
    ArcNode*firstarc;
}VNode,AdjList[MAXSIZE];
typedef struct Graph{
    AdjList vertices;//节点列表
    int vexnum,arcnum;//节点数和边数
}Graph;

bool TopologicalSort(Graph G)
{
    int print[G.vexnum];
    InitStack(S);
    for (int i=0;i<G.vexnum;i++)
    {
        if (Indegree[i]==0)
            push(S,i);
    }
    int count=0;
    while (!IsEmpty(S))
    {
        pop(S,i);
        print[count++]=i;
        for (p=G.vertices[i].firstarc;p;p=p->nextarc)
        {
            v=p->adjvex;
            if(!(--Indegree[v]))
                Push(S,v);
        }
    }
    if (count<G.vexnum)
        return false;
    else
        return true;
}
//正向输出print是拓朴排序,反向输出是逆拓朴排序
```

### **逆拓朴排序**

```c
//BFS
#define MAXSIZE 100 
bool visited[MAXSIZE];
void BFSTraverse(Graph G)
{
    for (int i=0;i<G.vexnum;i++)
        visited[i]=false;
    for(int i=0;i<G.vexnum;i++){
        if (!visited[i])
            DFS(G,i);
    }
}

void DFS(Graph G,int v)
{
    visited[v]=true;
    for (w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w))
    {
        if (!visited[w]){
            visit(w);
            DFS(G,w);
        }
        print(v);
    }
}
```

## 八、关键路径

$AOE$网络

- 以顶点表示时间,有向边表示活动,边上的权值表示活动的开销
- **仅有一个入度为$0$的顶点,称为开始顶点**（==源点==）
- **仅有一个出度为$0$的顶点,称为结束顶点**（==汇点==）
- 从源点到汇点的有向路径最大长度的路径称为==关键路径==,关键路径上的活动称为==关键活动==

### 1. 先进行拓朴排序,计算每个时间的最早发生时间$ve$

### 2. 逆拓朴排序顺序,根据最后一个节点来计算每个节点的最晚发生时间$vl$

### 3. 求每个时间的时间余量$d$,取$d=0$的活动就是关键活动,所有关键活动连接就是关键路径.

- 增加关键活动时间,工程时间增加
- 缩短关键活动时间,工程时间缩短；关键活动可能变为非关键活动

