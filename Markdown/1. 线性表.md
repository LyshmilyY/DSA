# 线性表

$$L=(a_{1},a_{2},a_{3},\dots,a_{i},a_{i+1},\dots,a_{n})$$

1. 有相同数据类型的 $n$ 个数据元素的有限序列

2. 需要在原数据上进行修改传地址(初始化、插入、删除)、仅仅统计某些值直接传值(长度、判空、打印)

3. 初始化传入的一定是引用,无论是指针还是结构体


```C
#include <assert.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <math.h>
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;

// 定义数据域
typedef struct elem
{
    char name[20];
    int Math;
    int English;
    int Politics;
    int Computer; 
}elem;

//线性表基本操作
InitList(&L) //初始化表,分配内存空间
DestroyList(&L) //销毁线性表,释放内存空间
ListInsert(&L,i,e) //在表L中第i个位置插入元素e
ListDelete(&L,i,&e) //删除表L中第i个位置的元素,并用e返回删除元素的值
LocateElem(&L,e) //在表L中按照值查找
GetElem(&L,i) //按位查找,获取表L中第i个位置的元素的值

Length(L) //求表的长度
Empty(L) //判断表L是否是空
PrintList(L) //打印表L中的元素
```

## 1. 顺序表 (动态内存实现)

1. 用顺序存储方式实现的线性表
2. 优点: 存储密度高,支持随机存取
3. 缺点: 大片连续空间分配不方便,改变容量不方便,插入和删除需要移动大量元素


```C
// 初始化
Status InitList(SqList * L)
{
    L->data = malloc(INITSIZE * sizeof(elem));
    if (!L->data) exit(OVERFLOW);
    L->length = 0;
    return OK;
}

// 增加表长
Status IncreaseSize(SqList * L, int len)
{
    elem *p = L->data;
    L->data = (elem *)malloc((L->MaxSize + len) * sizeof(elem));
    if (!L->data) exit(OVERFLOW);
    for (int i = 0; i < L->length; i++)
    {
        L->data[i] = p[i];
    }
    L->MaxSize += len;
    free(p);
    return OK;
}

// 插入
Status ListInsert(SqList * L, int i, elem e)
{
    if (i < 1 || i > L->length + 1) return ERROR;
    if (L->length >= L->MaxSize) IncreaseSize(L, INITSIZE);
    for (int j = L->length - 1; j >= i-1; j--)
    {
        L->data[j + 1] = L->data[j];
    }
    L->data[i - 1] = e;
    L->length++;
    return OK;
}

// 删除
Status ListDelete(SqList * L, int i, elem * e)
{
    if (i < 1 || i > L->length) return ERROR;
    *e = L->data[i - 1];
    for (int j = i; j < L->length; j++)
    {
        L->data[j - 1] = L->data[j];
    }
    L->length--;
    return OK;
}

// 按值查找
int LocateElem(SqList L, elem e)
{
    for (int i = 0; i < L.length; i++)
    {
        if (L.data[i].name == e.name) 
            return i + 1;
    }
    return ERROR;
}

// 按位查找
Status GetElem(SqList L, int i, elem * e)
{
    if (i < 1 || i > L.length) return ERROR;
    *e = L.data[i - 1];
    return OK;
}

// 表长
int Length(SqList L)
{
    return L.length;
}

// 判空
Status Empty(SqList L)
{
    if (L.length == 0) return OK;
    else return ERROR;
}

// 打印
void PrintList(SqList L)
{
    printf("%5s %15s %15s %15s %20s\n",
    "Name", "Score:Math", "Score:English", "Score:Politics", "Score:Computer");
    for (int i = 0; i < L.length; i++)
    {
        printf("%5s %10d %15d %15d %20d\n",
        L.data[i].name,L.data[i].Math,L.data[i].English,L.data[i].Politics,L.data[i].Computer);
    }
    printf("\n");
} 

void Printelem(elem e)
{
    printf("%5s %15s %15s %15s %20s\n",
    "Name", "Score:Math", "Score:English", "Score:Politics", "Score:Computer");
    printf("%5s %10d %15d %15d %20d\n",e.name,e.Math,e.English,e.Politics,e.Computer);
    printf("\n");
}
```



## 2. 单链表 (带头节点)

1. 每个节点包含数据项和指针项

2. 插入和删除时,第一个元素都要特殊考虑(具体实现)

3. 头插法和尾插法具体细节

``` c
// 初始化
Status InitList(LinkList *L)
{
    *L = (LNode *) malloc (sizeof(LNode));
    if (*L == NULL)
        return ERROR;
    (*L) ->next = NULL;
    return OK;
}

// 判空
Status Empty(LinkList L)
{
    if (L->next == NULL)
        return OK;
    return ERROR;
}

// 按值查找
LNode * LocateElem(LinkList L, elem e)
{
    LNode *p = L->next;
    while(p != NULL && p->data.name != e.name)
        p->next;
    return p;
}

// 按位查找 
LNode * GetElem(LinkList *L, int i)
{
    if (i < 1)
        return NULL;
    LNode *p = *L;
    // 第 j 个节点 p
    int j = 0;
    // 找到第 i 个元素的位置
    while (p !=NULL && j < i)
    {
        p = p->next;
        j++;
    }
    return p;
}

//指定元素后插入
Status InsertNextNode(LNode *p,elem e)
{
    LNode *s = (LNode *)malloc(sizeof(LNode));
    if (s == NULL || p == NULL)
        return ERROR;
    s->data = e;
    s->next = p->next;
    p->next = s;
    return OK;
}

//指定元素前插入
Status InsertPreNode(LNode *p,elem e)
{
    LNode *s = (LNode *)malloc(sizeof(LNode));
    if (s == NULL || p == NULL)
        return ERROR;
    s->next = p->next;
    p->next = s;
    s->data = p->data;
    p->data = e;
    return OK;
}

// 按位置插入
Status ListInsert(LinkList *L, int i, elem e)
{
    if (i < 1)
        return ERROR;
    if (i ==1)
        {
            LNode *s = (LNode *)malloc(sizeof(LNode));
            if (s == NULL)
                return ERROR;
            s->data = e;
            s->next = (*L)->next;
            (*L)->next = s;
            return OK;
        }
    LNode *p = GetElem(L,i-1);
    if (p == NULL)
        return ERROR;
    // 为新节点申请空间
    return InsertNextNode(p,e);
}



// 删除
Status ListDelete(LinkList *L, int i, elem * e)
{
    if (i < 1)
        return ERROR;
    if (i == 1)
    {
        if ((*L)->next == NULL)
            return ERROR;
        *e = (*L)->next->data;
        (*L)->next = (*L)->next->next;
        return OK;
    }
    LNode *p = GetElem(L,i-1);
    if (p == NULL || p->next == NULL)
        return ERROR;
    LNode * q = p->next;
    *e = q->data;
    p->next =q->next;
    //释放删除节点空间
    free(q);
    return OK;
}

// 删除指定节点
Status DeleteNode(LNode *p)
{
    if (p ==NULL)
        return ERROR;
    LNode *q = p->next;
    if (q == NULL)
        p == NULL;
    p->data = q->data;
    p->next = q->next;
    free(q);
    return OK;
}

// 表长
int Length(LinkList L)
{
    int len =0;
    LNode *p = L;
    while(p->next != NULL)
    {
        p = p->next;
        len++;
    }
    return len;
}
// 打印
void PrintList(LinkList L)
{
    printf("%5s %15s %15s %15s %20s\n",
    "Name", "Score:Math", "Score:English", "Score:Politics", "Score:Computer");
    LNode *p = L->next;
    while(p != NULL)
    {
        printf("%5s %10d %15d %15d %20d\n",
        p->data.name,p->data.Math,p->data.English,p->data.Politics,p->data.Computer);
        p = p->next;
    }
    printf("\n");
}

// 打印单个数据元素
void PrintNode(LNode p)
{
    printf("%5s %15s %15s %15s %20s\n",
    "Name", "Score:Math", "Score:English", "Score:Politics", "Score:Computer");
    printf("%5s %10d %15d %15d %20d\n",
    p.data.name,p.data.Math,p.data.English,p.data.Politics,p.data.Computer);
    printf("\n");
}
```

``` c
// 尾插法实现单链表
LinkList TailInsert(LinkList *L,int n)
{
    LNode *r = *L;
    for (int i = 0; i < n; i++)
    {
        LNode *p = (LNode*)malloc(sizeof(LNode));
        scanf("%s %d %d %d %d\n",p->data.name,&(p->data.Math),&(p->data.English),&(p->data.Politics),&(p->data.Computer));
        p->next = r->next;
        r->next = p;
        r = p;
    }
    return *L;

}
// 头插法实现单链表
LinkList HeadInsert(LinkList *L,int n)
{
    for (int i = 0; i < n; i++)
    {
        LNode *p = (LNode*)malloc(sizeof(LNode));
        scanf("%s %d %d %d %d\n",p->data.name,&(p->data.Math),&(p->data.English),&(p->data.Politics),&(p->data.Computer));
        p->next = (*L)->next;
        (*L)->next = p;
    }
    return *L;
}
// 反转单链表
void ListReverse(LinkList *L)
{
    LNode *p,*q;
    p = (*L)->next;
    (*L)->next = NULL;
    while(p != NULL)
    {
        q = p->next;
        p->next = (*L)->next;
        (*L)->next = p;
        p = q;
    }
}
```  
  

## 3. 双链表 (带头节点)


``` c

```

## 4. 循环双链表

```c

```



## 5. 静态链表

1. 优点: 离散的小空间分配方便,改变容量方便
2. 缺点: 不可随机存取,存储密度低



