# 1. 引论

- 数据结构是相互之间存在==一种或者多种特定关系==的==数据元素==的集合
- 数据结构三要素:==存储结构==（实现）、（==逻辑结构==、==运算逻辑）==）（定义）
- 存储结构:==顺序存储==、==链式存储==、==索引存储==、==散列存储==
- 算法:==有穷性、确定性、正确性、可读性==

# 2. 线性表

==初始化传入的一定是引用,无论是指针还是结构体==

$L=(a_{1},a_{2},a_{3},\dots,a_{i},a_{i+1},\dots,a_{n})$

- 有==相同数据类型==的==n==个数据元素的==有限==序列

- ==需要在原数据上进行修改传地址（初始化、插入、删除）==、==仅仅统计某些值直接传值（长度、判空、打印）==

  ```C
  //线性表基本操作
  //InitList(&L) 初始化表,分配内存空间
  //DestroyList(&L) 销毁线性表,释放内存空间
  //ListInsert(&L,i,e) 在表L中第i个位置插入元素e
  //ListDelete(&L,i,&e) 删除表L中第i个位置的元素,并用e返回删除元素的值
  //LocateElem(L,e) 在表L中按照值查找
  //GetElem(L,i) 按位查找,获取表L中第i个位置的元素的值
  
  //Length(L) 求表的长度
  //IsEmpty(L) 判断表L是否是空
  //增删改查,初始化,判空,销毁,表长
  ```

## 2 .1 顺序表

- 用==顺序存储方式==实现的==线性表==
- 优点:==存储密度高,支持随机存取==
- 缺点:==大片连续空间分配不方便,改变容量不方便,插入和删除需要移动大量元素==

**静态内存实现**

```C
#include <stdio.h>
#define MaxSize 10
typedef struct{
    int data[MaxSize];
    int length;
}SqList;
//初始化
void InitList(SqList *L){
    for (int i=0;i<MaxSize;i++)
        L->data[i]=0;
    L->length = 0;
}
int main()
{
    SqList L;
    InitList(&L);
    return 0;
}

```

**动态内存实现**  ==! ! !==

```C
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

//包括表,表已使用长度,表的容量
typedef struct{
    int *data;
    int length;
    int MaxSize;
}SqList;
//初始化
void InitList(SqList *L,int InitSize){
    L->data = (int *)malloc(InitSize*sizeof(int));
    L->length = 0;
    L->MaxSize=InitSize;
}
//动态增加顺序表的容量
//malloc 和 free 函数,申请内存空间,释放内存空间
void Increase(SqList *L,int len){
    int *p=L->data;
    L->data=(int *)malloc((L->MaxSize+len)*sizeof(int));
    for(int i=0;i<L->length;i++)
        L->data[i]=p[i];
    L->MaxSize+=len;
    free(p);
}
//插入元素,如果长度等于表长,增加一个表长,继续插入,返回值为插入成功与否
//O（n）
bool ListInsert(SqList *L,int i,int e){
    if(i<1 || i>L->length+1){
        return false;
    }
    if(L->length>=L->MaxSize)
        Increase(L,1);
    for(int j=L->length;j>=i;j--)
    {
        L->data[j]=L->data[j-1];
    }
    L->data[i-1]=e;
    L->length++;
    return true;
}
//删除元素,返回值为删除成功与否,并将删除的值复制给e
//O（n）
bool ListDelete(SqList *L,int i,int *e){
    if(i<1 || i>L->length){
        return false;
    }
    *e=L->data[i-1];
    for(int j=i;j<L->length;j++)
        L->data[j-1]=L->data[j];
    L->length--;
    return true;
}
//获取第i个元素,超出范围会out of range!
//O（1）
int GetElem(SqList L,int i){
    if(i<1 || i>L.length){
        printf("Error! Out of range!");
        return false;
    }
    return L.data[i-1];
}
//查询元素e在顺序表中的位置,没有返回0
//O（n）
int LocateElem(SqList L,int e)
{
    for(int i=0;i<L.length;i++)
    {
        if (L.data[i]==e)
            return i+1
    }
    return 0;
}
```



## 2.2 单链表

- ==每个节点包含数据项和指针项==

- 带头节点和不带头节点的实现

```c
  //带头节点实现
  #include <stdio.h>
  #include <stdbool.h>
  #include <stdlib.h>
  typedef struct LNode{
      int data;
      struct LNode *next;
  }LNode,*LinkList;
  
  //函数声明
  bool InitList(LinkList *L); //初始化
  bool IsEmpty(LinkList L); //判断链表是否为空
  LNode* GetElem(LinkList L,int e); //按值查找
  LNode* Getitem(LinkList L,int i);//获取链表中第i个节点
  bool InsertNextNode(LNode* p,int e); //在某个节点后插入节点
  bool InsertPriorNode(LNode *p,int e); //在某个节点前插入节点
  bool InsertList(LinkList* L,int i,int e); //在链表第i个位置插入节点
  bool ListDelete(LinkList* L,int i,int *e); //删除链表中的第i个节点
  int Length(LinkList L); //链表长度
  void PrintList(LinkList L); //打印链表中的元素
  void List_HeadInsert(LinkList *L); //头插法建立单链表
  void List_TailInsert(LinkList *L); //尾插法建立单链表
  
  
  //初始化
  bool InitList(LinkList *L){
      *L=(LNode *)malloc(sizeof(LNode));
      if(*L==NULL)
          return false;
      (*L)->next=NULL;
      return true;
  }
  //判断链表是否为空
  bool IsEmpty(LinkList L){
      return(L->next==NULL);
  }
  //增删查改
  //按照值查找节点
  LNode* GetElem(LinkList L,int e){
      LNode *p=L->next;
      while(p!=NULL&&p->data!=e)
          p=p->next;
      return p;
  }
  //获取链表第i个节点
  LNode* Getitem(LinkList L,int i)
  {
      int j=1;
      LNode * p=L;
      if (i<0)
          return NULL;
      if (i==0)
          return p;
      p=L->next;
      while (p!=NULL && j<i)
      {
          j++;
          p=p->next;
      }
      return p;
  }
  //在某个节点后插入节点
  bool InsertNextNode(LNode* p,int e){
      if(p==NULL)
          return false;
      LNode *s=(LNode*)malloc(sizeof(LNode));
      if(s==NULL)
          return false;
      s->data=e;
      s->next=p->next;
      p->next=s;
      return true;
  }
  //在某个节点前插入节点
  bool InsertPriorNode(LNode *p,int e){
      if(p==NULL)
          return false;
      LNode *s=(LNode*)malloc(sizeof(LNode));
      if(s==NULL)
          return false;
      s->next=p->next;
      p->next=s;
      s->data=p->data;
      p->data=e;
      return true;
  }
  //在链表第i个位置插入节点
  bool InsertList(LinkList* L,int i,int e){
      LNode* p=Getitem(*L,i-1);
      return InsertNextNode(p,e);
  }
  
  //删除链表中的第i个节点
  bool ListDelete(LinkList* L,int i,int *e){
      if(i<1)
          return false;
      LNode *p=*L;
      int j=0;
      while(p&&j<i-1){
          p=p->next;
          j++;
      }
      if(p==NULL)
          return false;
      LNode *q=p->next;
      *e=q->data;
      p->next=q->next;
      free(q);
      return true;
  }
  
  //链表长度
  int Length(LinkList L){
      int Length=0;
      LNode* p=L;
      while(p->next!=NULL){
          Length++;
          p=p->next;
      }
      return Length;
  }
  //打印链表中的元素
  void PrintList(LinkList L){
      LNode *p=L->next;
      while(p){
          printf("%d ",p->data);
          p=p->next;
      }
      printf("\n");
  }
  //头插法建立单链表
  void List_HeadInsert(LinkList *L){
      int x;
      LNode *s;
      InitList(L);
      scanf("%d",&x);
      while(x!=9999){
          s=(LNode*)malloc(sizeof(LNode));
          s->data=x;
          s->next=(*L)->next;
          (*L)->next=s;
          scanf("%d",&x);
      }
  }
  
  //尾插法建立单链表
  void List_TailInsert(LinkList *L){
      int x;
      LNode *s,*r;
      InitList(L);
      r=*L;
      scanf("%d",&x);
      while(x!=9999){
          s=(LNode*)malloc(sizeof(LNode));
          s->data=x;
          r->next=s;
          r=s;
          scanf("%d",&x);
      }
      r->next=NULL;
  }
  ```
  
 ```c
  //无头节点实现
  #include <stdio.h>
  #include <stdbool.h>
  #include <stdlib.h>
  typedef struct LNode{
      int data;
      struct LNode *next;
  }LNode,*LinkList;
  
  //函数声明
  void InitList(LinkList* L); //初始化
  bool IsEmpty(LinkList L); //判断链表是否为空
  LNode* Getitem(LinkList L,int i); //获取链表中的第i个节点
  bool InsertNextNode(LNode* p,int e); //在某个节点后插入节点
  bool InsertPriorNode(LNode* p,int e); //在某个节点前插入节点
  bool InsertList(LinkList* L,int i,int e); //在链表第i个位置插入节点
  bool ListDelete(LinkList* L,int i,int *e); //删除链表中的第i个节点
  int Length(LinkList L); //链表长度
  void PrintList(LinkList L); //打印链表中的元素
  void List_HeadInsert(LinkList *L); //头插法建立单链表
  void List_TailInsert(LinkList *L); //尾插法建立单链表
  
  //初始化
  void InitList(LinkList *L){
      *L=NULL;
  }
  //判断链表是否为空
  bool IsEmpty(LinkList L){
      return(L==NULL);
  }
  //获取链表中的第i个节点
  LNode* Getitem(LinkList L,int i){
      int j=1;
      LNode *p=L;
      if(i<1)
          return NULL;
      while(p&&j<i)
      {
          p=p->next;
          j++;
      }
      return p;
  }
  //在某个节点后插入节点
  bool InsertNextNode(LNode* p,int e){
      if(p==NULL)
          return false;
      LNode *s=(LNode*)malloc(sizeof(LNode));
      if(s==NULL)
          return false;
      s->data=e;
      s->next=p->next;
      p->next=s;
      return true;
  }
  //在某个节点前插入节点
  bool InsertPriorNode(LNode *p,int e){
      if(p==NULL)
          return false;
      LNode *s=(LNode*)malloc(sizeof(LNode));
      if(s==NULL)
          return false;
      s->data=p->data;
      s->next=p->next;
      p->data=e;
      p->next=s;
      return true;
  }
  //在链表第i个位置插入节点
  bool InsertList(LinkList* L,int i,int e){
      if (i<1)
          return false;
      if(i==1){
          LNode *s=(LNode*)malloc(sizeof(LNode));
          s->data=e;
          s->next=*L;
          *L=s;
          return true;
      }
      LNode *p=Getitem(*L,i-1);
      return InsertNextNode(p,e);
  }
  //删除链表中的第i个节点
  bool ListDelete(LinkList* L,int i,int *e){
      if(i<1)
          return false;
      if(i==1){
          LNode *p=*L;
          *L=(*L)->next;
          *e=p->data;
          free(p);
          return true;
      }
      LNode *p=Getitem(*L,i-1);
      if(p==NULL)
          return false;
      LNode *q=p->next;
      *e=q->data;
      p->next=q->next;
      free(q);
      return true;
  }
  //链表长度
  int Length(LinkList L){
      int length=0;
      LNode *p=L;
      while(p)
      {
          p=p->next;
          length++;
      }
      return length;
  }
  //打印链表中的元素
  void PrintList(LinkList L){
      LNode *p=L;
      while(p)
      {
          printf("%d ",p->data);
          p=p->next;
      }
      printf("\n");
  }
  //头插法建立单链表
  void List_HeadInsert(LinkList *L){
      int x;
      LNode *s;
      scanf("%d",&x);
      if(x!=9999){
          *L=(LNode *)malloc(sizeof(LNode));
          (*L)->data=x;
          (*L)->next=NULL;
          scanf("%d",&x);
          while(x!=9999)
          {
              s=(LNode*)malloc(sizeof(LNode));
              s->data=x;
              s->next=(*L);
              (*L)=s;
              scanf("%d",&x);
          }
      }
  }
  //尾插法建立单链表
  void List_TailInsert(LinkList *L){
      int x;
      LNode *s,*r;
      r=*L;
      scanf("%d",&x);
      if(x!=9999){
          *L=(LNode *)malloc(sizeof(LNode));
          (*L)->data=x;
          (*L)->next=NULL;
          r=*L;
          scanf("%d",&x);
          while(x!=9999)
          {
              s=(LNode*)malloc(sizeof(LNode));
              s->data=x;
              r->next=s;
              r=s;
              scanf("%d",&x);
          }
          r->next=NULL;
      }
  }
  ```
  
  

## 2.3 双链表

- 头插法和尾插法实现时,==前者保持\*L不变,一直在\*L后插入节点==；后者则是==新建一个指针指向最后一个节点,最后将这个指针的next设置为NULL==

```c
//带头节点实现
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
typedef struct DNode{
    int data;
    struct DNode *next,*prior;
}DNode,*DLinkList;

//函数声明
bool InitList(DLinkList *L); //初始化
bool IsEmpty(DLinkList L); //判断链表是否为空
DNode* Getitem(DLinkList L,int e); //获取链表中的第i个节点
bool InsertNextNode(DNode* p,int e); //在某个节点后插入节点
bool InsertPriorNode(DNode* p,int e); //在某个节点前插入节点
bool InsertList(DLinkList* L,int i,int e); //在链表第i个位置插入节点
bool ListDelete(DLinkList* L,int i,int *e); //删除链表中的第i个节点
int Length(DLinkList L); //链表长度
void PrintList(DLinkList L); //打印链表中的元素
void List_HeadInsert(DLinkList *L);//头插法
void List_TailInsert(DLinkList *L);//尾插法

//初始化
bool InitList(DLinkList *L){
    *L=(DNode*)malloc(sizeof(DNode));
    if(*L==NULL)
        return false;
    (*L)->next=NULL;
    (*L)->prior=NULL;
    return true;
}
//判断双链表是否为空
bool IsEmpty(DLinkList L){
    return(L->next==NULL);
}
//获取链表中的第i个节点
DNode* Getitem(DLinkList L,int i){
    int j=1;
    DNode *p=L;
    if (i<0)
        return NULL;
    if (i==0)
        return p;
    p=L->next;
    while(p&&j<i)
    {
        p=p->next;
        j++;
    }
    return p;
}
//在某个节点后插入节点
bool InsertNextNode(DNode* p,int e){
    if(p==NULL)
        return false;
    DNode *s=(DNode*)malloc(sizeof(DNode));
    if(s==NULL)
        return false;
    s->data=e;
    s->next=p->next;
    if(p->next!=NULL)
        p->next->prior=s;
    s->prior=p;
    p->next=s;
    return true;
}
//在某个节点前插入节点
bool InsertPriorNode(DNode *p,int e){
    if(p==NULL)
        return false;
    DNode *s=(DNode*)malloc(sizeof(DNode));
    if(s==NULL)
        return false;
    s->data=e;
    s->prior=p->prior;
    if(p->prior!=NULL)
        p->prior->next=s;
    s->next=p;
    p->prior=s;
    return true;
}
//在链表第i个位置插入节点
bool InsertList(DLinkList* L,int i,int e){
    if (i<1)
        return false;
    DNode *p=Getitem(*L,i-1);
    if(p==NULL)
        return false;
    return InsertNextNode(p,e);
}
//删除链表中的第i个节点
bool ListDelete(DLinkList* L,int i,int *e){
    if (i<1)
        return false;
    DNode *p=Getitem(*L,i);
    if(p==NULL)
        return false;
    *e=p->data;
    if(p->next!=NULL)
        p->next->prior=p->prior;
    p->prior->next=p->next;
    free(p);
    return true;
}
//链表长度
int Length(DLinkList L){
    int j=0;
    DNode *p=L;
    while(p->next!=NULL)
    {
        p=p->next;
        j++;
    }
    return j;
}
//打印链表中的元素
void PrintList(DLinkList L){
    DNode *p=L->next;
    while(p!=NULL)
    {
        printf("%d ",p->data);
        p=p->next;
    }
    printf("\n");
}
//头插法建立双链表
void List_HeadInsert(DLinkList *L){
    int x;
    DNode* s;
    *L=(DNode*)malloc(sizeof(DNode));
    (*L)->next=NULL;
    (*L)->prior=NULL;
    scanf("%d",&x);
    while(x!=9999)
    {
        s=(DNode*)malloc(sizeof(DNode));
        s->data=x;
        s->next=(*L)->next;
        if((*L)->next!=NULL)
            (*L)->next->prior=s;
        s->prior=(*L);
        (*L)->next=s;
        scanf("%d",&x);
    }
}
//尾插法建立双链表
void List_TailInsert(DLinkList *L){
    int x;
    DNode* s;
    DNode* r;
    *L=(DNode*)malloc(sizeof(DNode));
    (*L)->next=NULL;
    (*L)->prior=NULL;
    r=*L;
    scanf("%d",&x);
    while(x!=9999)
    {
        s=(DNode*)malloc(sizeof(DNode));
        s->data=x;
        r->next=s;
        s->prior=r;
        r=s;
        scanf("%d",&x);
    }
    r->next=NULL;
}
```

- 节点前插和节点后插没有区别,最大的问题是==指定位置插入首个节点的问题==


```c
//无头节点双链表实现
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
typedef struct DNode{
    int data;
    struct DNode *next,*prior;
}DNode,*DLinkList;

//函数声明
void InitList(DLinkList *L); //初始化
bool IsEmpty(DLinkList L); //判断链表是否为空
DNode* Getitem(DLinkList L,int i); //获取链表中的第i个节点
bool InsertNextNode(DNode* p,int e); //在某个节点后插入节点
bool InsertPriorNode(DNode *p,int e); //在某个节点前插入节点
bool InsertList(DLinkList *L,int i,int e); //在链表第i个位置插入节点
bool ListDelete(DLinkList *L,int i,int *e); //删除链表中的第i个节点
int Length(DLinkList L); //链表长度
void PrintList(DLinkList L); //打印链表中的元素
void List_HeadInsert(DLinkList *L);
void List_TailInsert(DLinkList *L);

//初始化
void InitList(DLinkList *L){
    *L=NULL;
}
//判断双链表是否为空
bool IsEmpty(DLinkList L){
    return(L==NULL);
}
//获取链表中的第i个节点
DNode* Getitem(DLinkList L,int i){
    int j=1;
    DNode *p=L;
    if(i<1)
        return NULL;
    while(p&&j<i)
    {
        p=p->next;
        j++;
    }
    return p;
}
//在某个节点后插入节点
bool InsertNextNode(DNode* p,int e){
    if(p==NULL)
        return false;
    DNode *s=(DNode*)malloc(sizeof(DNode));
    if(s==NULL)
        return false;
    s->data=e;
    s->next=p->next;
    if(p->next!=NULL)
        p->next->prior=s;
    s->prior=p;
    p->next=s;
    return true;
}
//在某个节点前插入节点
bool InsertPriorNode(DNode *p,int e){
    if(p==NULL)
        return false;
    DNode *s=(DNode*)malloc(sizeof(DNode));
    if(s==NULL)
        return false;
    s->data=e;
    s->prior=p->prior;
    if(p->prior!=NULL)
        p->prior->next=s;
    s->next=p;
    p->prior=s;
    return true;
}
//在链表第i个位置插入节点
bool InsertList(DLinkList *L,int i,int e){
    if(i==1){
        DNode* s=(DNode*)malloc(sizeof(DNode));
        s->data=e;
        s->next=*L;
        if((*L)!=NULL){
            (*L)->prior=s;
        }
        s->prior=NULL;
        *L=s;
        return true;
    }
    if(i<1)
        return false;
    DNode *p=Getitem(*L,i-1);
    if(p==NULL)
        return false;
    return InsertNextNode(p,e);
}
//删除链表中的第i个节点
bool ListDelete(DLinkList *L,int i,int *e){
    if(i<1 || (*L)==NULL)
        return false;
    if (i==1){
        DNode *p=*L;
        *L=(*L)->next;
        if((*L)!=NULL)
            (*L)->prior=NULL;
        *e=p->data;
        free(p);
        return true;
    }
    DNode *p=Getitem(*L,i);
    if(p==NULL)
        return false;
    *e=p->data;
    if(p->next!=NULL)
        p->next->prior=p->prior;
    p->prior->next=p->next;
    free(p);
    return true;
}
//链表长度
int Length(DLinkList L){
    int length=0;
    DNode *p=L;
    while(p!=NULL)
    {
        p=p->next;
        length++;
    }
    return length;
}
//打印链表中的元素
void PrintList(DLinkList L){
    DNode *p=L;
    while(p!=NULL)
    {
        printf("%d ",p->data);
        p=p->next;
    }
    printf("\n");
}
//头插法建立双链表
void List_HeadInsert(DLinkList *L){
    int x;
    DNode* s;
    scanf("%d",&x);
    if(x!=9999){
        *L=(DLinkList)malloc(sizeof(DNode));
        (*L)->data=x;
        (*L)->prior=NULL;
        (*L)->next=NULL;
        scanf("%d",&x);
        while(x!=9999)
        {
            s=(DNode*)malloc(sizeof(DNode));
            s->data=x;
            s->prior=NULL;
            s->next=(*L);
            (*L)->prior=s;
            (*L)=s;
            scanf("%d",&x);
        }
    }
}
//尾插法建立双链表
void List_TailInsert(DLinkList *L){
    InitList(L);
    int x;
    DNode* s;
    DNode* r;
    scanf("%d",&x);
    if(x!=9999){
        *L=(DLinkList)malloc(sizeof(DNode));
        (*L)->data=x;
        (*L)->prior=NULL;
        (*L)->next=NULL;
        r=*L;
        scanf("%d",&x);
        while(x!=9999)
        {
            s=(DNode*)malloc(sizeof(DNode));
            s->data=x;
            s->prior=r;
            r->next=s;
            r=s;
            scanf("%d",&x);
        }
        r->next=NULL;
    }
}
```

## 2.4 循环链表

- 同样有带头节点和不带头节点两种实现
- 循环单链表

```c
//带头节点实现
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
typedef struct Node
{
    int data;
    struct Node *next;
}CNode,*CLinkList;

//函数声明
bool InitList(CLinkList *L); //初始化
bool IsEmpty(CLinkList L); //判断链表是否为空
CNode* Getitem(CLinkList L,int i); //获取链表中的第i个节点
bool InsertNextNode(CNode* p,int e); //在某个节点后插入节点
bool InsertPriorNode(CNode *p,int e); //在某个节点前插入节点
bool InsertList(CLinkList* L,int i,int e); //在链表第i个位置插入节点
bool ListDelete(CLinkList* L,int i,int *e); //删除链表中的第i个节点
int Length(CLinkList L); //链表长度
void PrintList(CLinkList L); //打印链表中的元素
void List_HeadInsert(CLinkList *L); //头插法建立单链表
void List_TailInsert(CLinkList *L); //尾插法建立单链表


//初始化
bool InitList(CLinkList *L)
{
    *L = (CNode*)malloc(sizeof(CNode));
    if(*L == NULL)
        return false;
    (*L)->next = *L;
    return true;
}
//判断链表是否为空
bool IsEmpty(CLinkList L)
{
    if(L->next == L)
        return true;
    return false;
}
//获取链表中的第i个节点
CNode* Getitem(CLinkList L,int i)
{
    if(i <0)
        return NULL;
    if (i==0)
        return L;
    CNode *p = L->next;
    int j = 1;
    while(p != L && j < i)
    {
        p = p->next;
        j++;
    }
    if(p == L)
        return NULL;
    return p;
}
//在某个节点后插入节点
bool InsertNextNode(CNode* p,int e)
{
    if(p == NULL)
        return false;
    CNode *s = (CNode*)malloc(sizeof(CNode));
    if(s == NULL)
        return false;
    s->data = e;
    s->next = p->next;
    p->next = s;
    return true;
}
//在某个节点前插入节点
bool InsertPriorNode(CNode *p,int e)
{
    if(p == NULL)
        return false;
    CNode *s = (CNode*)malloc(sizeof(CNode));
    if(s == NULL)
        return false;
    s->next = p->next;
    p->next = s;
    s->data = p->data;
    p->data = e;
    return true;
}
//在链表第i个位置插入节点
bool InsertList(CLinkList *L,int i,int e)
{
    if(i < 1)
        return false;
    if (i==1)
    {
        CNode *q=(CNode*)malloc(sizeof(CNode));
        q->data=e;
        q->next=(*L)->next;
        (*L)->next=q;
        return true;
    }
    CNode *p = Getitem(*L,i-1);
    if(p == NULL)
        return false;
    return InsertNextNode(p,e);
}
//删除链表中的第i个节点
bool ListDelete(CLinkList* L,int i,int *e)
{
    if(i < 1)
        return false;
    if (i==1)
    {
        CNode *p = (*L)->next;
        if (p==*L)
            return false;
        *e = p->data;
        (*L)->next = p->next;
        free(p);
        return true;
    }
    CNode *p = Getitem(*L,i-1);
    CNode *q = p->next;
    if(q == *L)
        return false;
    *e = q->data;
    p->next = q->next;
    free(q);
    return true;
}
//链表长度
int Length(CLinkList L)
{
    CNode *p = L->next;
    int len = 0;
    while(p != L)
    {
        len++;
        p = p->next;
    }
    return len;
}
//打印链表中的元素
void PrintList(CLinkList L)
{
    CNode *p = L->next;
    while(p != L)
    {
        printf("%d ",p->data);
        p = p->next;
    }
    printf("\n");
}

//头插法建立循环单链
void List_HeadInsert(CLinkList *L)
{
    InitList(L);
    int x;
    CNode *s;
    scanf("%d",&x);
    while(x != 9999)
    {
        s = (CNode*)malloc(sizeof(CNode));
        s->data = x;
        s->next = (*L)->next;
        (*L)->next = s;
        scanf("%d",&x);
    }
}
//尾插法建立循环单链表
void List_TailInsert(CLinkList *L)
{
    InitList(L);
    CNode *r = *L;
    int x;
    scanf("%d",&x);
    while(x != 9999)
    {
        CNode *s = (CNode*)malloc(sizeof(CNode));
        s->data = x;
        r->next = s;
        r = s;
        scanf("%d",&x);
    }
    r->next = *L;
}
```

- 循环双链表

```c
//带头节点实现
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
typedef struct DNode{
    int data;
    struct DNode *next,*prior;
}DNode,*CDLinkList;

//函数声明
bool InitList(CDLinkList *L); //初始化
bool IsEmpty(CDLinkList L); //判断链表是否为空
DNode* Getitem(CDLinkList L,int i); //获取链表中的第i个节点
bool InsertNextNode(DNode* p,int e); //在某个节点后插入节点
bool InsertPriorNode(DNode* p,int e); //在某个节点前插入节点
bool InsertList(CDLinkList* L,int i,int e); //在链表第i个位置插入节点
bool ListDelete(CDLinkList* L,int i,int *e); //删除链表中的第i个节点
int Length(CDLinkList L); //链表长度
void PrintList(CDLinkList L); //打印链表中的元素
void List_HeadInsert(CDLinkList *L);
void List_TailInsert(CDLinkList *L);

//初始化
bool InitList(CDLinkList *L){
    *L=(DNode*)malloc(sizeof(DNode));
    if(*L==NULL)
        return false;
    (*L)->next=*L;
    (*L)->prior=*L;
}
//判断双链表是否为空
bool IsEmpty(CDLinkList L){
    return(L->next==L);
}
//获取链表中的第i个节点
DNode* Getitem(CDLinkList L,int i){
    int j=1;
    DNode *p=L->next;
    if(i<0)
        return NULL;
    if(i==0)
        return L;
    while(p!=L&&j<i)
    {
        p=p->next;
        j++;
    }
    return p;
}
//在某个节点后插入节点
bool InsertNextNode(DNode* p,int e){
    if(p==NULL)
        return false;
    DNode *s=(DNode*)malloc(sizeof(DNode));
    if(s==NULL)
        return false;
    s->data=e;
    s->next=p->next;
    p->next->prior=s;
    s->prior=p;
    p->next=s;
    return true;
}
//在某个节点前插入节点
bool InsertPriorNode(DNode *p,int e){
    if(p==NULL)
        return false;
    DNode *s=(DNode*)malloc(sizeof(DNode));
    if(s==NULL)
        return false;
    s->data=e;
    s->prior=p->prior;
    p->prior->next=s;
    s->next=p;
    p->prior=s;
    return true;
}
//在链表第i个位置插入节点
bool InsertList(CDLinkList* L,int i,int e){
    if (i<1)
        return false;
    DNode *p=Getitem(*L,i-1);
    if(p==NULL)
        return false;
    if(p==*L && i!=1)
        return false;
    return InsertNextNode(p,e);
}
//删除链表中的第i个节点
bool ListDelete(CDLinkList* L,int i,int *e){
    DNode *p=Getitem(*L,i);
    if(p==NULL)
        return false;
    if (p==*L && i!=1)
        return false;
    *e=p->data;
    p->next->prior=p->prior;
    p->prior->next=p->next;
    free(p);
    return true;
}
//链表长度
int Length(CDLinkList L){
    int j=0;
    DNode *p=L->next;
    while(p->next!=L)
    {
        p=p->next;
        j++;
    }
    return j;
}
//打印链表中的元素
void PrintList(CDLinkList L){
    DNode *p=L->next;
    while(p!=L)
    {
        printf("%d ",p->data);
        p=p->next;
    }
    printf("\n");
}
//头插法建立双链表
void List_HeadInsert(CDLinkList *L){
    int x;
    CDLinkList s;
    InitList(L);
    scanf("%d",&x);
    while(x!=9999)
    {
        s=(CDLinkList)malloc(sizeof(DNode));
        s->data=x;
        s->next=(*L)->next;
        (*L)->next->prior=s;
        s->prior=(*L);
        (*L)->next=s;
        scanf("%d",&x);
    }
}
//尾插法建立双链表
void List_TailInsert(CDLinkList *L){
    int x;
    CDLinkList s,r;
    InitList(L);
    r=*L;
    scanf("%d",&x);
    while(x!=9999)
    {
        s=(CDLinkList)malloc(sizeof(DNode));
        s->data=x;
        r->next=s;
        s->prior=r;
        r=s;
        scanf("%d",&x);
    }
    r->next=*L;
    (*L)->prior=r;
}
```



## 2.5 静态链表

###### 优点:==离散的小空间分配方便,改变容量方便==
###### 缺点:==不可随机存取,存储密度低==



