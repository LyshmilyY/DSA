# 树和森林

## 1. 树的基本概念

## 2. 二叉树概念

## 3. 二叉树的遍历和线索二叉树

## 4. 树和森林

## 5. 哈夫曼树及其应用
树是$n$个节点的有限集,当$n=0$时为空树.

- ==非空树满足有且仅有一个根节点==
- 当$n>1$时,除根节点外的节点可以分为$m$个互不相交的有限集$T_{1},T_{2},\cdots,T_{m}$,每个集合本身也是一棵树,称为==根节点的子树==
- ==除根节点外,每个节点都有唯一前驱==
- ==树中所有节点都可以有多个或者零个后继==

==树的基本术语==

- 父节点、子节点、兄弟节点
- ==节点的度==:节点子节点个数
- ==节点度数等于$0$==的节点称为==叶节点==或者==终端节点==
- 节点的==高度（从下往上）==、==深度（从上往下）==和层次
- ==有序树==和==无序树==:前者节点的子树从左到右有顺序；后者没有顺序

==树的性质==

- 树的节点数量$n$等于所有节点度数之和加$1$  $$n=\sum Degree(Node)+1$$

- 度为$m$的树第$i$层最多有$m^{i-1}$个节点

- 高度为$h$的$m$叉树至多有$1+m+m^2+\cdots+m^{h-1}$个节点 $$ N=\dfrac{m^{h}-1}{m-1}$$

- 具有$n$个节点的$m$叉树的最小高度为:
	- 高度为 $h$ 的 $m$ 叉树至多有节点个数:$N_{1}=\dfrac{m^{h-1}-1}{m-1}$
	- 高度为 $h-1$ 的 $m$ 叉树至多有节点个数:$N_{2}=\dfrac{m^{h-1}-1}{m-1}$
	- 我们有:$\dfrac{m^{h-1}-1}{m-1}\leq n\leq \dfrac{m^{h}-1}{m-1}$
	- $log_{m}(n(m-1)+1)\leq h\leq log_{m}(n(m-1)+1)+1$
	- 最小高度:$h_{min}=[log_{m}(n(m-1)+1)+1]$

  

## 二、二叉树

### 1. 二叉树定义

二叉树是一种特殊的树形结构,每个节点至多有两颗子树,二叉树有左子树和右子树的区分

### 2. 二叉树分类

#### （1）满二叉树:树的高度为$h$,且含有$2^{h}-1$个节点的二叉树

#### （2）完全二叉树:高度为$h$,含有$n$节点的二叉树,当且仅当每个节点和高度为$h$的满二叉树编号为$1\sim n$节点一一对应

- ==叶节点编号==:$i>[\dfrac{n}{2}]$
- 叶节点只能出现在最后两层,对于最大层的叶节点,从左到右依次排列
- ==节点度数为$1$的节点数量可能为$0$或者$1$==
- $n$为奇数,除叶结点外每个节点都有左子树和右子树；$n$为偶数,有且仅有编号为$\dfrac{n}{2}$的节点只有左子树,没有右子树

#### （3）二叉排序树:左子树上所有节点的关键字小于根节点的关键字；右子树上所有节点的关键字大于根节点的关键字

#### （4）平衡二叉树:树上任意节点的左子树和右子树的深度之差不超过$1$

### 3. 二叉树性质

- 对于二叉树节点,我们可以分为度数为$0$的节点,度数为$1$的节点,度数为$2$的节点；节点数量依次为$n_{0},n_{1},n_{2}$,我们有:
$$\left\{ \begin{matrix}
  n=n_{0}+n_{1}+n_{2}\\
  n=2n_{2}+n_{1}+1(\text{根节点})
  \end{matrix}
  \right.\Rightarrow n_{0}=n_{2}+1$$
- 非空二叉树第$k$层最多有$2^{k-1}$个节点
- 高度为$h$的二叉树最多有$2^k-1$个节点
- ==完全二叉树==从上到下从左到右对节点进行编号,我们有:
  - 对于编号为$i$的节点,左子树编号为$2i$,右子树编号为$2i+1$
  - 对于编号为$i$的节点,如果$i$是偶数,其父节点编号为$\dfrac{n}{2}$,是父节点的左子树；如果$i$是奇数,其父节点编号为$[\dfrac{n}{2}]$,是父节点的右子树
  - 节点$i$所在的层次为$[log_{2}i]+1$
- 具有$n$个节点的完全二叉树的高度为:$[log_{2}n]+1$或者$[log_{2}(n+1)]$

### 4. 二叉树实现

#### （1）顺序存储

```c
//主要适用于完全二叉树
#include<stdio.h>
#include<stdlib.h>
#include<stdbool.h>
#define MAXSIZE 100
typedef struct BNode{
    int data[MAXSIZE];
    int numNode;
}BNode,*BTree;

//函数声明
void InitTree(BTree *T);//初始化树
void InsertNode(BTree *T,int x);//添加节点
int GetLeftNode(BTree T,int i);//获取左子节点
int GetRightNode(BTree T,int i);//获取右子节点
int GetParentNode(BTree T,int i);//获取父节点
int GetDepth(BTree T,int i);//获取深度
void LevelOrder(BTree T);//层序遍历


//初始化
void InitTree(BTree *T){
    *T = (BTree)malloc(sizeof(struct BNode));
    (*T)->numNode = 0;
}

//添加节点
void InsertNode(BTree *T,int x){
    (*T)->data[(*T)->numNode+1] = x;
    (*T)->numNode++;
}

//获取左子节点
int GetLeftNode(BTree T,int i){
    if(i*2 <= T->numNode){
        return T->data[i*2];
    }
    return -1;
}

//获取右子节点
int GetRightNode(BTree T,int i){
    if(i*2+1 <= T->numNode){
        return T->data[i*2+1];
    }
    return -1;
}

//获取父节点
int GetParentNode(BTree T,int i){
    if(i/2 >= 1){
        return T->data[i/2];
    }
    return -1;
}

//获取深度
int GetDepth(BTree T,int i){
    int depth = 0;
    while(i/2 >= 1){
        i = i/2;
        depth++;
    }
    return depth;
}

//层序遍历
void LevelOrder(BTree T){
    int i = 1;
    while(i <= T->numNode){
        printf("%d ",T->data[i]);
        i++;
    }
}
```

#### （2）链式存储

```c
#include<stdio.h>
#include<stdlib.h>
#include<stdbool.h>
typedef struct BiTNode{
    int data;
    struct BiTNode *lchild,*rchild,*parent;
}BiTNode,*BiTree;

//函数声明
void InitTree(BiTree *T);//初始化树
BiTNode* CreateNode(int x);//创建节点
bool InsertLeftNode(BiTNode *p,int x);//添加左子节点
bool InsertRightNode(BiTNode *p,int x);//添加右子节点
BiTNode* GetLeftNode(BiTNode *p);//获取左子节点
BiTNode* GetRightNode(BiTNode *p);//获取右子节点
BiTNode* GetParentNode(BiTNode *p);//获取父节点
int GetDepth(BiTNode *p);//获取深度
void LevelOrder(BiTree T);//层序遍历
void PreOrder(BiTree T);//先序遍历
void InOrder(BiTree T);//中序遍历
void PostOrder(BiTree T);//后序遍历
void Visit(BiTNode *p);//访问节点

//初始化
void InitTree(BiTree *T){
    *T = NULL;
}

//创建节点
BiTNode* CreateNode(int x){
    BiTNode *p = (BiTNode*)malloc(sizeof(BiTNode));
    p->data = x;
    p->lchild = NULL;
    p->rchild = NULL;
    p->parent = NULL;
    return p;
}

//添加左子节点
bool InsertLeftNode(BiTNode *p,int x){
    if (p->lchild != NULL){
        return false;
    }
    BiTNode *q = CreateNode(x);
    p->lchild = q;
    q->parent = p;
    return true;
}

//添加右子节点
bool InsertRightNode(BiTNode *p,int x){
    if (p->rchild != NULL){
        return false;
    }
    BiTNode *q = CreateNode(x);
    p->rchild = q;
    q->parent = p;
    return true;
}

//获取左子节点
BiTNode* GetLeftNode(BiTNode *p){
    return p->lchild;
}

//获取右子节点
BiTNode* GetRightNode(BiTNode *p){
    return p->rchild;
}

//获取父节点
BiTNode* GetParentNode(BiTNode *p){
    return p->parent;
}

//获取节点深度
int GetDepth(BiTNode *p){
    int depth = 0;
    while(p->parent != NULL){
        p = p->parent;
        depth++;
    }
    return depth;
}
//获取树的深度
int treeDepth(BiTree T){
    if (T==NULL)
    {
        return 0;
    }
    else
    {
        int l=treeDepth(T->lchild);
        int r=treeDepth(T->rchild);
        return l>r ? l+1:r+1;
    }
}

//层序遍历
void LevelOrder(BiTree T){
    BiTNode *queue[100];
    int front = 0,rear = 0;
    if (T != NULL){
        queue[rear++] = T;
    }
    while(front != rear){
        BiTNode *p = queue[front++];
        Visit(p);
        if (p->lchild != NULL){
            queue[rear++] = p->lchild;
        }
        if (p->rchild != NULL){
            queue[rear++] = p->rchild;
        }
    }
}

//先序遍历
void PreOrder(BiTree T){
    if (T != NULL){
        Visit(T);
        PreOrder(T->lchild);
        PreOrder(T->rchild);
    }
}

//中序遍历
void InOrder(BiTree T){
    if (T != NULL){
        InOrder(T->lchild);
        Visit(T);
        InOrder(T->rchild);
    }
}

//后序遍历
void PostOrder(BiTree T){
    if (T != NULL){
        PostOrder(T->lchild);
        PostOrder(T->rchild);
        Visit(T);
    }
}

//访问节点
void Visit(BiTNode *p){
    printf("%d ",p->data);
}
```

### 5. 二叉树遍历和线索二叉树

![](https://yjl0928-image-1328687625.cos.ap-beijing.myqcloud.com/Image/DSA-%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86.png)


#### （1）前序遍历:==根节点$\Rightarrow$左子树$\Rightarrow$右子树==

```c
//非递归实现,一路向左,一直压栈,左为空弹栈访问根节点然后将节点指向右子节点重复操作
void InOrder(BiTree T)
{
    Stack S;
    BiTree P=T;
    InitStack(&S);
    while (p || !IsEmpty(S))
    {
        if (p)
        {
            Visit(p);
            Push(&S,p);
            p=p->lchild;
        }
        else
        {
            Pop(&S,p);
            p=p->rchild;
        }
    }
}
```

#### （2）中序遍历:==左子树$\Rightarrow$根节点$\Rightarrow$右子树==

```c
//非递归实现,一路向左,一直压栈,左为空弹栈访问根节点然后将节点指向右子节点重复操作
void InOrder(BiTree T)
{
    Stack S;
    BiTree P=T;
    InitStack(&S);
    while (p || !IsEmpty(S))
    {
        if (p)
        {
            Push(&S,p);
            p=p->lchild;
        }
        else
        {
            Pop(&S,p);
            Visit(p);
            p=p->rchild;
        }
    }
}

```

#### （3）后序遍历:==左子树$\Rightarrow$右子树$\Rightarrow$根节点==

```c
//非递归实现

```

二叉树的==先序遍历和中序遍历==可以唯一确定一颗二叉树；二叉树的==后序遍历和中序遍历==可以唯一确定一颗二叉树；二叉树的==层次遍历和中序遍历==可以唯一的确定一颗二叉树.

![](https://yjl0928-image-1328687625.cos.ap-beijing.myqcloud.com/Image/DSA-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%81%8D%E5%8E%86.png)

- ==先序遍历分析树得到前缀表达式==
- ==中序遍历得到中缀表达式==
- ==后序遍历得到后缀表达式==

#### （4）层次遍历

```c
typedef struct LinkNode{
    BiTree* data;
    struct LinkNode* next;
}LinkNode;
typedef struct LinkQueue{
    LinkNode* front;
    LinkNode* rear;
}LinkQueue;
void LevelOrder(BiTree T)
{
    LinkQueue Q;
    InitQueue(&Q);
    BiTree p;
    EnQueue(&Q,T);
    while (!IsEmpty(Q)){
        DeQueue(&Q,p);
        visit(p);
        if (p->lchild!=NULL)
            EnQueue(&Q,p->lchild);
        if (p->rchild!=NULL)
            EnQueue(&Q,p->rchild);
    }
}
```



#### （5）线索二叉树:方便从一个指定节点出发,找到前驱、后继,方便遍历

```c
typedef struct ThreadNode{
    int data;
    struct ThreadNode* lchild;
    struct ThreadNode* rchild;
    int ltag,rtag;//指针标识,指针为1代表线索
}ThreadNode,*ThreadTree;
```

- 中序线索二叉树:以==中序遍历==为依据进行“线索化”

![](https://yjl0928-image-1328687625.cos.ap-beijing.myqcloud.com/Image/DSA-%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.png)

  ```c
  //中序遍历
  ThreadNode *pre=NULL//全局变量
  void InThread(ThreadTree T)
  {
      if (T!=NULL)
      {
          InThread(T->lchild);
          visit(T);
          InThread(T->rchild);
      }
  }
  //访问节点
  void visit(ThreadNode * q)
  {
      if (q->lchild==NULL)
      {
          q->lchild=pre;
          q->ltag=1;
      }
      if (pre!=NULL && pre->rchild==NULL)
      {
          pre->rchild=q;
          pre->rtag=1;
      }
      pre=q;
  }
  //中序线索化二叉树
  void CreateThread(ThreadTree T)
  {
      pre=NULL;
      if (T!=NULL)
      {
          InThread(T);
          if (pre->rchild==NULL)
          {
              pre->rtag=1;
          }
      }
  }
  ```

- 先序线索二叉树:以==先序遍历==为依据进行“线索化”

![](https://yjl0928-image-1328687625.cos.ap-beijing.myqcloud.com/Image/DSA-%E5%85%88%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.png)

  ```c
  //先序遍历
  ThreadNode *pre=NULL//全局变量
  void PreThread(ThreadTree T)
  {
      if (T!=NULL)
      {
          visit(T);
          if (T->ltag==0)
              PreThread(T->lchild)
          PreThread(T->rchild);
      }
  }
  //访问节点
  void visit(ThreadNode * q)
  {
      if (q->lchild==NULL)
      {
          q->lchild=pre;
          q->ltag=1;
      }
      if (pre!=NULL && pre->rchild==NULL)
      {
          pre->rchild=q;
          pre->rtag=1;
      }
      pre=q;
  }
  //中序线索化二叉树
  void CreateThread(ThreadTree T)
  {
      pre=NULL;
      if (T!=NULL)
      {
          PreThread(T);
          if (pre->rchild==NULL)
          {
              pre->rtag=1;
          }
      }
  }
  ```

- 后序线索二叉树:以==后序遍历==为依据进行“线索化”

![](https://yjl0928-image-1328687625.cos.ap-beijing.myqcloud.com/Image/DSA-%E5%90%8E%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.png)

  ```c
  //后序遍历
  ThreadNode *pre=NULL//全局变量
  void PostThread(ThreadTree T)
  {
      if (T!=NULL)
      {
          PostThread(T->lchild);
          visit(T);
          PostThread(T->rchild);
      }
  }
  //访问节点
  void visit(ThreadNode * q)
  {
      if (q->lchild==NULL)
      {
          q->lchild=pre;
          q->ltag=1;
      }
      if (pre!=NULL && pre->rchild==NULL)
      {
          pre->rchild=q;
          pre->rtag=1;
      }
      pre=q;
  }
  //后序线索化二叉树
  void CreateThread(ThreadTree T)
  {
      pre=NULL;
      if (T!=NULL)
      {
          PostThread(T);
          if (pre->rchild==NULL)
          {
              pre->rtag=1;
          }
      }
  }
  ```

  

## 三、树和森林

### 1. 树和森林的存储结构

- ==双亲表示法== （顺序存储）

  ==方便找父亲节点；找孩子节点不方便,只能遍历整个数组==

![](https://yjl0928-image-1328687625.cos.ap-beijing.myqcloud.com/Image/DSA-%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95.png)

  ```c
  #define MAXSIZE 100
  //树节点定义
  typedef struct PTNode
  {
      ElemType data;
      int parent;
  }PTNode;
  
  //用数组来存储树节点
  typedef struct PTree
  {
      PTNode nodes[MAXSIZE];
      int n;//节点总数
  }PTree;
  ```

- ==孩子表示法== （顺序存储+链式存储）

  ==找孩子方便；找父亲节点不方便==

  ![](https://yjl0928-image-1328687625.cos.ap-beijing.myqcloud.com/Image/DSA-%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95.png)

  ```c
  typedef struct CNode
  {
      int child;//节点在数组中的位置
      struct CNode* next;//下一个孩子指针
  }CNode;
  
  typedef struct CBox
  {
      int data;
      struct CNode *firstchild;
  }CBox;
  
  typedef struct CTree{
      CBoxs nodes[MAXSIZE];
      int n,r;//节点数和根的位置
  }CTree;
  ```

- ==孩子兄弟表示法== （链式存储）

  ```c
  typedef struct CSNode
  {
      int data;
      struct CSNode* firstchild;
      struct CSNode* nextsibling;
  }CSNode,*CSTree;
  ```

### 2. 二叉树、森林和树的转换

==利用孩子兄弟表示法来进行转换==

（1）二叉树$\Rightarrow$树       树$\Rightarrow$二叉树  

![](https://yjl0928-image-1328687625.cos.ap-beijing.myqcloud.com/Image/DSA-%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E6%A0%91.png)

![](https://yjl0928-image-1328687625.cos.ap-beijing.myqcloud.com/Image/DSA-%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%A0%91.png)

（2）森林$\Rightarrow$二叉树      二叉树$\Rightarrow$森林    

![](https://yjl0928-image-1328687625.cos.ap-beijing.myqcloud.com/Image/DSA-%E6%A3%AE%E6%9E%97%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.png)

![](https://yjl0928-image-1328687625.cos.ap-beijing.myqcloud.com/Image/DSA-%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%A3%AE%E6%9E%97.png)

### 3. 树和森林的遍历

#### 树:先根遍历和后根遍历

==先根遍历==:和对应的二叉树的先序遍历结果相同

==后根遍历==:和对应的二叉树的中序遍历结果相同

#### 森林:先序遍历和中序遍历

==先序遍历==:对应的二叉树先序遍历

==中序遍历==:对应的二叉树中序遍历

## 四、树和树的应用

### 1. 哈夫曼树

在含有$n$个带权叶节点的二叉树中,带权路径$(WPL)$最小的二叉树称为==哈夫曼树==,也称为最优二叉树.

![](https://yjl0928-image-1328687625.cos.ap-beijing.myqcloud.com/Image/DSA-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E6%9E%84%E9%80%A0.png)

**哈夫曼编码**

- 前缀编码:没有一个编码是另一个编码的前缀
- ==固定长度编码==:每个字符用相等长度的二进制位表示
- ==可变长度编码==:允许对不同字符用不等长的二进制位表示

### 2. 并查集

**用森林来表示总体,总体里各个集合代表互不相交的子树,采用双亲表示法**

```c
#define SIZE 50
int UFSets[SIZE];//集合元素数组
//初始化、查找、合并

void Initial(int s[])
{
    for (int i=0;i<SIZE;i++)
        s[i]=-1;
}

int Find(int s[],int x)
{
    while(s[x]>=0)
    {
        x=s[x]
    }
    return x;
}
//Find优化
int Find(int s[],int x)
{
    int root=x;
    while(s[root]>=0) root=s[root];
    while(x!=root){
        int t=s[x];
        s[x]=root;
        x=t;
    }
    return root;
}



void Union(int s[],int Root1,int Root2)
{
    if (Root1==Root2)
        return ;
    s[Root2]=Root1;
}

//Union 进一步优化,用根节点的绝对值表示树的节点数,合并时小树合并到大树

void Union(int s[],int Root1,int Root2)
{
    if (Root1==Root2)
        return ;
    if (s[Root1]<s[Root2])
    {
        s[Root1]+=s[Root2];
        s[Root2]=Root1;
    }
    else
    {
         s[Root2]+=s[Root1];
        s[Root1]=Root2;
    }
}

```

![](https://yjl0928-image-1328687625.cos.ap-beijing.myqcloud.com/Image/DSA-%E5%B9%B6%E6%9F%A5%E9%9B%86.png)

[**Disjoint Sets**](https://www.cs.usfca.edu/~galles/visualization/DisjointSets.html)